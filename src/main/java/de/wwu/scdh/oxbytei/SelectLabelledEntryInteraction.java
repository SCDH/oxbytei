package de.wwu.scdh.oxbytei;

import java.awt.Frame;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import javax.xml.transform.URIResolver;
//import java.nio.file.ProviderNotFoundException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.w3c.dom.Document;

import org.xml.sax.EntityResolver;

import ro.sync.ecss.extensions.api.ArgumentDescriptor;
import ro.sync.ecss.extensions.api.ArgumentsMap;
import ro.sync.ecss.extensions.api.AuthorAccess;
import ro.sync.ecss.extensions.api.AuthorConstants;

import de.wwu.scdh.teilsp.config.EditorVariablesExpander;
import de.wwu.scdh.teilsp.exceptions.ConfigurationException;
import de.wwu.scdh.teilsp.services.extensions.ILabelledEntriesProvider;
import de.wwu.scdh.teilsp.services.extensions.LabelledEntriesLoader;
import de.wwu.scdh.teilsp.services.extensions.ExtensionException;
import de.wwu.scdh.teilsp.services.extensions.SelectionDialogLoader;
import de.wwu.scdh.oxbytei.commons.EditorVariablesExpanderImpl;
import de.wwu.scdh.oxbytei.commons.WSDocumentReader;
import de.wwu.scdh.oxbytei.commons.DocumentReaderException;
import de.wwu.scdh.oxbytei.commons.AuthorDocumentReader;
import de.wwu.scdh.oxbytei.commons.OperationArgumentValidator;
import de.wwu.scdh.oxbytei.commons.RollbackException;
import de.wwu.scdh.teilsp.exceptions.UIException;
import de.wwu.scdh.teilsp.exceptions.ProviderNotFoundException;
import de.wwu.scdh.teilsp.ui.ISelectionDialog;



/**
 * {@link SelectLabelledEntryInteraction} provides plugin lookup and
 * interaction with the user.  It is intended to be mixed into a
 * derived {@link AuthorOperation} by composition.
 *
 * After making an instance call {@link doUserInteraction()} to let the
 * user interactively select values generated by the plugins.
 *
 * This class also provides constants for the arguments, with which an
 * author mode action can be parametrized. For that perpose it also
 * provides the static method {@link #getArguments()}.
 *
 * @author Christian LÃ¼ck
 */
public class SelectLabelledEntryInteraction
    implements InteractiveOperation {

    public static final String[] ARGUMENT_BOOLEAN_VALUES = new String[] {
	AuthorConstants.ARG_VALUE_FALSE,
	AuthorConstants.ARG_VALUE_TRUE
    };

    public static final ArgumentDescriptor ARGUMENT_ROLLBACK_ON_CANCEL =
	new ArgumentDescriptor("rollbackOnCancel",
			       ArgumentDescriptor.TYPE_CONSTANT_LIST,
			       "This controls how a cancellation of the user dialog is handled."
			       + " In chains of multiple actions throwing an error an stopping the chain"
			       + " is a good idea."
			       + "\n\nDefaults to true.",
			       ARGUMENT_BOOLEAN_VALUES,
			       AuthorConstants.ARG_VALUE_FALSE);

    public static final ArgumentDescriptor ARGUMENT_MESSAGE =
	new ArgumentDescriptor("message",
			       ArgumentDescriptor.TYPE_STRING,
			       "The message in the user dialog.");

    public static final ArgumentDescriptor ARGUMENT_DIALOG =
	new ArgumentDescriptor("dialog",
			       ArgumentDescriptor.TYPE_STRING,
			       "The user dialogue used for this operation.",
			       "de.wwu.scdh.teilsp.ui.ComboBoxSelectDialog");

    public static final URL DEFAULT_ICON =
	SelectLabelledEntryInteraction.class.getResource("/images/ask-24.png");

    public static final ArgumentDescriptor ARGUMENT_ICON =
	new ArgumentDescriptor("icon",
			       ArgumentDescriptor.TYPE_STRING,
			       "The icon displayed in the user dialogue.",
			       DEFAULT_ICON.toString());

    public static final ArgumentDescriptor ARGUMENT_DELIMITER =
	new ArgumentDescriptor("valuesDelimiter",
			       ArgumentDescriptor.TYPE_STRING,
			       "The string that separates multiple selected values."
			       + "\nDefaults to space.",
			       " ");

    public static final ArgumentDescriptor ARGUMENT_DELIMITER_REGEX =
	new ArgumentDescriptor("valuesDelimiterRegex",
			       ArgumentDescriptor.TYPE_STRING,
			       "A regular expression for splitting multiple values in the current value string."
			       + "\nDefaults to whitespace.",
			       "\\s+");

    /**
     * Return an array of the arguments usually needed.
     */
    public static final ArgumentDescriptor[] getArguments() {
	return new ArgumentDescriptor[] {
	    ARGUMENT_DIALOG,
	    ARGUMENT_ROLLBACK_ON_CANCEL,
	    ARGUMENT_MESSAGE,
	    ARGUMENT_ICON,
	    ARGUMENT_DELIMITER,
	    ARGUMENT_DELIMITER_REGEX
	};
    }

    private static final Logger LOGGER = LoggerFactory.getLogger(SelectLabelledEntryInteraction.class);

    /**
     * The type of the node to be edited.
     */
    protected String nodeType;

    /**
     * Attribute or element name to be set by the operation
     */
    protected String nodeName;

    /**
     * Namespace of the element or attribute name to be set by the operation
     *
     */
    protected String nodeNamespace;

    /**
     * The XPath location relative to the current editing position that identifies the element.
     */
    protected String location;

    protected WSDocumentReader documentReader;
    protected URIResolver uriResolver;
    protected EntityResolver entityResolver;
    protected URL currentFileURL;
    protected EditorVariablesExpander expander;
    protected Frame frame;

    protected List<ILabelledEntriesProvider> providers;
    protected int providersCount;

    protected Document document;
    protected String configFile;

    /**
     * The current editing context as an XPath expression.
     */
    private String context;

    /**
     * The constructor loads the plugins for the current editing
     * context and configures them based on the config file.
     *
     * @param authorAccess {@link AuthorAccess} from the author operation
     * current caret position that identifies the element
     */
    public SelectLabelledEntryInteraction (AuthorAccess authorAccess) {
	// authorAccess is not accessible from outside of this
	// constructor because we want to make this class re-usable in
	// other editor modes!

	documentReader = new AuthorDocumentReader(authorAccess);

    	// get the uri resolver, entity resolver used by oxygen and editing context
	uriResolver = authorAccess.getXMLUtilAccess().getURIResolver();
	entityResolver = authorAccess.getXMLUtilAccess().getEntityResolver();
	currentFileURL = authorAccess.getEditorAccess().getEditorLocation();

	// get an expander for editor variables
	expander = new EditorVariablesExpanderImpl(authorAccess, currentFileURL, true);

	frame = (Frame) authorAccess.getWorkspaceAccess().getParentFrame();
    }

    /**
     * This loads the plugins for the current editing
     * context and configures them based on the config file.
     *
     * @param nodeType the type of the node to be edited
     * @param nodeName the local name of the node to be edited
     * @param nodeNamespace the namespace part of the node's name
     * @param location the relative XPath location with respect to the
     * current caret position that identifies the element
     */
    public int init
	(final String nodeType,
	 final String nodeName,
	 final String nodeNamespace,
	 final String location)
	throws ConfigurationException, ExtensionException, DocumentReaderException {

	this.nodeType = nodeType;
	this.nodeName = nodeName;
	this.nodeNamespace = nodeNamespace;
	this.location = location;

	// get the URL of the configuration file
	configFile = OxbyteiConstants.getConfigFile();

	document = documentReader.getDocument();
	context = documentReader.getContextXPath();

	LOGGER.debug("Loading providers for {} {} on context {}", nodeType, nodeName, context);
	providers = new ArrayList<ILabelledEntriesProvider>();
	providers = LabelledEntriesLoader.providersForContext
	    (document,
	     currentFileURL.toString(),
	     context,
	     nodeType,
	     nodeName,
	     uriResolver,
	     entityResolver,
	     null,
	     configFile,
	     expander);

	providersCount = providers.size();
	return providersCount;
    }

    /**
     * Do the actual user interaction.
     */
    public String doUserInteraction(final ArgumentsMap arguments)
	throws UIException, ConfigurationException, ExtensionException, RollbackException  {

	// get current value
	String currentValue = documentReader.lookupNode(nodeType, location, nodeName, nodeNamespace);

	// get arguments from arguments map
	String rollbackOnCancelString =
	    OperationArgumentValidator.validateStringArgument(ARGUMENT_ROLLBACK_ON_CANCEL.getName(), arguments);
	boolean rollbackOnCancel = rollbackOnCancelString.equals(AuthorConstants.ARG_VALUE_TRUE);
	String message =
	    OperationArgumentValidator.validateStringArgument(ARGUMENT_MESSAGE.getName(), arguments);
	String iconString =
	    OperationArgumentValidator.validateStringArgument(ARGUMENT_ICON.getName(), arguments);
	URL icon;
	try {
	    icon = new URL(iconString);
	} catch (MalformedURLException e) {
	    icon = DEFAULT_ICON;
	}
	String dialog =
	    OperationArgumentValidator.validateStringArgument(ARGUMENT_DIALOG.getName(), arguments);
	String valuesDelimiter =
	    OperationArgumentValidator.validateStringArgument(ARGUMENT_DELIMITER.getName(), arguments);
	String valuesDelimiterRegex =
	    OperationArgumentValidator.validateStringArgument(ARGUMENT_DELIMITER_REGEX.getName(), arguments);

	// split current string value by delimiter regex
	List<String> currentSelection;
	if (valuesDelimiter != null && currentValue != null) {
	    currentSelection = Arrays.asList(currentValue.split(valuesDelimiterRegex));
	} else {
	    currentSelection = new ArrayList<String>();
	    currentSelection.add(currentValue);
	}

	// get the dialog
	ISelectionDialog dialogView;
	if (providersCount == 0) {
	    // use fallback dialog
	    // TODO: this prevents us from configuring dialogs in
	    // contexts without providers. Is this wanted?
	    dialogView = fallbackDialog();
	} else {
	    LOGGER.debug("Loading providers for {} {} on context {}", nodeType, nodeName, context);
	    List<ISelectionDialog> dialogs = new ArrayList<ISelectionDialog>();
	    dialogs = SelectionDialogLoader.providersForContext
		(document,
		 currentFileURL.toString(),
		 context,
		 nodeType,
		 nodeName,
		 uriResolver,
		 entityResolver,
		 null,
		 configFile,
		 frame,
		 expander);
	    if (dialogs.size() == 0) {
		dialogView = fallbackDialog();
	    } else {
		// we take the first dialog found in the config
		dialogView = dialogs.get(0);
		// TODO: should we dispose all plugins or does GC the job?
	    }
	}

	// envoke the dialog and get the selection/input
	List<String> selected;
	dialogView.setup(currentSelection, providers);
	dialogView.doUserInteraction();
	selected = dialogView.getSelection();

	// set the value, if not null returned form
	// doUserInteraction(), because null means cancellation
	if (selected != null) {
	    // make the new value
	    String newValue = "";
	    for (int i = 0; i < selected.size(); i++) {
		if (i > 0) {
		    // add separator
		    newValue += valuesDelimiter;
		}
		newValue += selected.get(i);
	    }
	    // store in state variable
	    GlobalState.selection = newValue;
	    // return
	    return newValue;
	} else {
	    if (rollbackOnCancel) {
		throw new RollbackException("rolling back");
	    }
	    // store in state variable
	    GlobalState.selection = currentValue; // TODO: OK ???
	    // return value
	    return null;
	}
    }

    protected ISelectionDialog fallbackDialog()
	throws ConfigurationException, ExtensionException {
	ISelectionDialog dialog, dialogView;
	try {
	    dialog = SelectionDialogLoader.provider();
	    Class dialogClass = dialog.getClass();
	    dialogView = (ISelectionDialog) dialogClass.getDeclaredConstructor(Frame.class).newInstance(frame);

	    Map<String, String> arguments = new HashMap<String, String>();
	    arguments.put("title", "New value");
	    arguments.put("icon", null);
	    dialogView.init(arguments);
	} catch (ProviderNotFoundException e) {
	    throw new ConfigurationException
		("Default dialog view "
		 + SelectionDialogLoader.DEFAULT_PROVIDER
		 + " not found");
	} catch (InstantiationException e) {
	    throw new ExtensionException
		("Error instantiating user dialog class "
		 + SelectionDialogLoader.DEFAULT_PROVIDER
		 + "\n\n" + e);
	} catch (IllegalAccessException e) {
	    throw new ExtensionException
		("Error accessing user dialog class "
		 + SelectionDialogLoader.DEFAULT_PROVIDER
		 + "\n\n" + e);
	} catch (NoSuchMethodException e) {
	    throw new ExtensionException
		("Error loading dialog class "
		 + SelectionDialogLoader.DEFAULT_PROVIDER
		 + "\n\n" + e);
	} catch (InvocationTargetException e) {
	    throw new ExtensionException
		("Error loading dialog class "
		 + SelectionDialogLoader.DEFAULT_PROVIDER
		 + "\n\n" + e);
	}

	// TODO dispose dialog
	return dialogView;
    }
}
